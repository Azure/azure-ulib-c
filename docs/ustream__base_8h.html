<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uLib: C:/repos/uLib-WIP/doxy/inc/ustream_base.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uLib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_0852b6145d5475d7a8e4df489fe46e4c.html">doxy</a></li><li class="navelem"><a class="el" href="dir_c37d36cfe6658755c708757fc9743def.html">inc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ustream_base.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>uStream Interface  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="ulib__config_8h_source.html">ulib_config.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ulib__result_8h_source.html">ulib_result.h</a>&quot;</code><br />
<code>#include &quot;azure_macro_utils/macro_utils.h&quot;</code><br />
<code>#include &quot;umock_c/umock_c_prod.h&quot;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div>
<p><a href="ustream__base_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_i_o_t___u_s_t_r_e_a_m___t_a_g.html">AZIOT_USTREAM_TAG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface description.  <a href="struct_a_z_i_o_t___u_s_t_r_e_a_m___t_a_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_i_o_t___u_s_t_r_e_a_m___i_n_t_e_r_f_a_c_e___t_a_g.html">AZIOT_USTREAM_INTERFACE_TAG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">vTable with the uStream APIs.  <a href="struct_a_z_i_o_t___u_s_t_r_e_a_m___i_n_t_e_r_f_a_c_e___t_a_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9f3237e600295f7aa5483bec5bf71d4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustream__base_8h.html#a9f3237e600295f7aa5483bec5bf71d4a">AZIOT_USTREAM_IS_NOT_TYPE_OF</a>(handle,  type_api)&#160;&#160;&#160;((handle == NULL) || (handle-&gt;api != &amp;type_api))</td></tr>
<tr class="memdesc:a9f3237e600295f7aa5483bec5bf71d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a handle is the same type of the API.  <a href="#a9f3237e600295f7aa5483bec5bf71d4a">More...</a><br /></td></tr>
<tr class="separator:a9f3237e600295f7aa5483bec5bf71d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad6d3ac7a653ebc380309a369ca677d58"><td class="memItemLeft" align="right" valign="top"><a id="ad6d3ac7a653ebc380309a369ca677d58"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustream__base_8h.html#ad6d3ac7a653ebc380309a369ca677d58">offset_t</a></td></tr>
<tr class="memdesc:ad6d3ac7a653ebc380309a369ca677d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define offset_t with the same size as size_t. <br /></td></tr>
<tr class="separator:ad6d3ac7a653ebc380309a369ca677d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96bde7ce8774e13db9c76ba9146ccd8"><td class="memItemLeft" align="right" valign="top"><a id="ab96bde7ce8774e13db9c76ba9146ccd8"></a>
typedef struct <a class="el" href="struct_a_z_i_o_t___u_s_t_r_e_a_m___i_n_t_e_r_f_a_c_e___t_a_g.html">AZIOT_USTREAM_INTERFACE_TAG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustream__base_8h.html#ab96bde7ce8774e13db9c76ba9146ccd8">AZIOT_USTREAM_INTERFACE</a></td></tr>
<tr class="memdesc:ab96bde7ce8774e13db9c76ba9146ccd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of AZIOT_USTREAM_INTERFACE. <br /></td></tr>
<tr class="separator:ab96bde7ce8774e13db9c76ba9146ccd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1021e37ea11b8861699ca4525ae307"><td class="memItemLeft" align="right" valign="top"><a id="a6f1021e37ea11b8861699ca4525ae307"></a>
typedef struct <a class="el" href="struct_a_z_i_o_t___u_s_t_r_e_a_m___t_a_g.html">AZIOT_USTREAM_TAG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a></td></tr>
<tr class="memdesc:a6f1021e37ea11b8861699ca4525ae307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface description. <br /></td></tr>
<tr class="separator:a6f1021e37ea11b8861699ca4525ae307"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a14cee0219d3b0168050603b63de6ab95"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustream__base_8h.html#a14cee0219d3b0168050603b63de6ab95">aziot_ustream_set_position</a> (<a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *ustream_interface, <a class="el" href="ustream__base_8h.html#ad6d3ac7a653ebc380309a369ca677d58">offset_t</a> position)</td></tr>
<tr class="memdesc:a14cee0219d3b0168050603b63de6ab95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the current position of the uStream.  <a href="#a14cee0219d3b0168050603b63de6ab95">More...</a><br /></td></tr>
<tr class="separator:a14cee0219d3b0168050603b63de6ab95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90577ebc92e787b53bed8af5560a670"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustream__base_8h.html#ad90577ebc92e787b53bed8af5560a670">aziot_ustream_reset</a> (<a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *ustream_interface)</td></tr>
<tr class="memdesc:ad90577ebc92e787b53bed8af5560a670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the current position to the first valid position.  <a href="#ad90577ebc92e787b53bed8af5560a670">More...</a><br /></td></tr>
<tr class="separator:ad90577ebc92e787b53bed8af5560a670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad136e857813def18c0261a686b74a681"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustream__base_8h.html#ad136e857813def18c0261a686b74a681">aziot_ustream_read</a> (<a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *ustream_interface, uint8_t *const buffer, size_t buffer_length, size_t *const size)</td></tr>
<tr class="memdesc:ad136e857813def18c0261a686b74a681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next portion of the uStream starting at the current position.  <a href="#ad136e857813def18c0261a686b74a681">More...</a><br /></td></tr>
<tr class="separator:ad136e857813def18c0261a686b74a681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42807a0d0c70f512774a380a05185e56"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustream__base_8h.html#a42807a0d0c70f512774a380a05185e56">aziot_ustream_get_remaining_size</a> (<a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *ustream_interface, size_t *const size)</td></tr>
<tr class="memdesc:a42807a0d0c70f512774a380a05185e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the remaining size of the uStream.  <a href="#a42807a0d0c70f512774a380a05185e56">More...</a><br /></td></tr>
<tr class="separator:a42807a0d0c70f512774a380a05185e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eaed6a11daecfd39aca4f0377b9779f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustream__base_8h.html#a4eaed6a11daecfd39aca4f0377b9779f">aziot_ustream_get_position</a> (<a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *ustream_interface, <a class="el" href="ustream__base_8h.html#ad6d3ac7a653ebc380309a369ca677d58">offset_t</a> *const position)</td></tr>
<tr class="memdesc:a4eaed6a11daecfd39aca4f0377b9779f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current position in the uStream.  <a href="#a4eaed6a11daecfd39aca4f0377b9779f">More...</a><br /></td></tr>
<tr class="separator:a4eaed6a11daecfd39aca4f0377b9779f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeea0517ae993f549c2901730746c7a8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustream__base_8h.html#abeea0517ae993f549c2901730746c7a8">aziot_ustream_release</a> (<a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *ustream_interface, <a class="el" href="ustream__base_8h.html#ad6d3ac7a653ebc380309a369ca677d58">offset_t</a> position)</td></tr>
<tr class="memdesc:abeea0517ae993f549c2901730746c7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all the resources related to the <code><code>Data Source</code></code> before and including the released position.  <a href="#abeea0517ae993f549c2901730746c7a8">More...</a><br /></td></tr>
<tr class="separator:abeea0517ae993f549c2901730746c7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ab120cb2e618f0d650c0938c32a97b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustream__base_8h.html#ae9ab120cb2e618f0d650c0938c32a97b">aziot_ustream_clone</a> (<a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *ustream_interface, <a class="el" href="ustream__base_8h.html#ad6d3ac7a653ebc380309a369ca677d58">offset_t</a> offset)</td></tr>
<tr class="memdesc:ae9ab120cb2e618f0d650c0938c32a97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of the uStream and returns it.  <a href="#ae9ab120cb2e618f0d650c0938c32a97b">More...</a><br /></td></tr>
<tr class="separator:ae9ab120cb2e618f0d650c0938c32a97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6453826de26b4a336372c2075ccb2a46"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustream__base_8h.html#a6453826de26b4a336372c2075ccb2a46">aziot_ustream_dispose</a> (<a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *ustream_interface)</td></tr>
<tr class="memdesc:a6453826de26b4a336372c2075ccb2a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all the resources allocated to control the instance of the uStream.  <a href="#a6453826de26b4a336372c2075ccb2a46">More...</a><br /></td></tr>
<tr class="separator:a6453826de26b4a336372c2075ccb2a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59af936377f98e35cfd035f20ca3f5e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ustream__base_8h.html#a59af936377f98e35cfd035f20ca3f5e7">aziot_ustream_append</a> (<a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *ustream_interface, <a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *ustream_to_append)</td></tr>
<tr class="memdesc:a59af936377f98e35cfd035f20ca3f5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a uStream to the existing uStream.  <a href="#a59af936377f98e35cfd035f20ca3f5e7">More...</a><br /></td></tr>
<tr class="separator:a59af936377f98e35cfd035f20ca3f5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>uStream Interface </p>
<p>This is the definition of a heterogeneous buffer that helps other modules in a system expose large amounts of data without using a large amount of memory. Modules in the system can expose their own data using this interface. To do that, the module shall implement the functions in the interface. This implementation shall follow the definition described in this file, which includes not only the prototype of the header, but the behavior as well. uStream defines a provider-consumer interface when:</p><ul>
<li><b>Provider</b> - is the module of code that handles data to be exposed. This module implements the uStream interface to expose the data to the consumer.</li>
<li><b>Consumer</b> - is the module of code that will use the data exposed by the provider.</li>
</ul>
<p>The uStream shall have a clear separation between the internal content (provider domain) and what it exposes as external content (consumer domain). The uStream shall never expose the internal content (ex: providing a pointer to a internal memory position). All exposed content shall be copied from the internal data source to some given external memory. To do that in a clear way, the uStream shall always work with the concept of two buffers, the <code>data source</code> and the <code>local buffer</code>, adhering to the following definition:</p><ul>
<li><b>Data source</b> - is the place where the data is stored by the implementation of the uStream interface. The data source is in the provider domain, and it shall be protected, immutable, and non volatile. Consumers can read the data from the data source by the calling the <a class="el" href="ustream__base_8h.html#ad136e857813def18c0261a686b74a681" title="Gets the next portion of the uStream starting at the current position.">aziot_ustream_read()</a> API, which will copy a snapshot of the data to the provided external memory, called local buffer.</li>
<li><b>Local buffer</b> - is the consumer domain buffer, where the <a class="el" href="ustream__base_8h.html#ad136e857813def18c0261a686b74a681" title="Gets the next portion of the uStream starting at the current position.">aziot_ustream_read()</a> API will copy the required bytes from the data source. The local buffer belongs to the consumer of this interface, which means that the consumer shall allocate and free (if necessary) this memory, and the content of the local buffer can be changed and released.</li>
</ul>
<p><em><b>Example</b></em></p>
<p>A provider wants to create a uStream to expose data to the consumer. The provider will store the content in the HEAP, and will create a uStream from it, passing the ownership of the content to the uStream. Consumer will print the content of the uStream, using a local buffer of 1K. The following diagram represents this operation.</p>
<pre><code>
 +----------------+        +----------------+         +------------------+     +------------+
 |    Provider    |        |    Consumer    |         |      uStream     |     |    HEAP    |
 +----------------+        +----------------+         +------------------+     +------------+
         |                         |                            |                    |
         |&lt;-get_provider_content()-+                            |                    |
         +----------------------------malloc(content_size)--------------------------&gt;|
         |&lt;--------------------------------content_ptr-------------------------------+
  +------+                         |                            |                    |
  | generate the content and store in the content_ptr           |                    |
  +-----&gt;|                         |                            |                    |
         +-----aziot_ustream_create                             |                    |
         |       (content_ptr, content_size, take_ownership)---&gt;|                    |
         |                         |                     +------+                    |
         |                         |                     | data_source = content_ptr |
         |                         |                     | data_source_size = content_size
         |                         |                     | ownership = true          |
         |                         |                     +-----&gt;|                    |
         |&lt;-----------------ustream_interface-------------------+                    |
         +-ustream_interface------&gt;|                            |                    |</code></pre><pre><code></code></pre><p>Now that the consumer has the uStream with the content, it will print it using the iterator <a class="el" href="ustream__base_8h.html#ad136e857813def18c0261a686b74a681" title="Gets the next portion of the uStream starting at the current position.">aziot_ustream_read()</a>.</p>
<pre><code></code></pre><pre><code>         |                         +------------------malloc(1024)------------------&gt;|
         |                         |&lt;-----------------local_buffer-------------------+
 .. while aziot_ustream_read return AZIOT_ULIB_SUCCESS .........................................
 :       |                         +--aziot_ustream_read        |                    |         :
 :       |                         |  (ustream_interface,       |                    |         :
 :       |                         |   local_buffer,            |                    |         :
 :       |                         |   1024)-------------------&gt;|                    |         :
 :       |                         |                     +------+                    |         :
 :       |                         |                     | copy the next 1024 bytes from the   :
 :       |                         |                     |  data_source to the local_buffer.   :
 :       |                         |                     +-----&gt;|                    |         :
 :       |                         |&lt;---AZIOT_ULIB_SUCCESS------+                    |         :
 :       |                  +------+                            |                    |         :
 :       |                  | use the content in the local_buffer                    |         :
 :       |                  +-----&gt;|                            |                    |         :
 ...............................................................................................
         |                         +---------------free(local_buffer)---------------&gt;|
         |                         +-aziot_ustream_dispose            |              |
         |                         |       (ustream_interface)-&gt;|                    |
         |                         |                            +-free(data_source)-&gt;|
         |                         |                            |                    |
</code></pre><h2>Heterogeneous buffer</h2>
<p>Data can be stored in multiple, different medias, like RAM, flash, file, or cloud. Each media has its own read requirements. A simple way to unify it is copying it all to the RAM. For example, if an HTTP package contains a header that is in the flash, with some data in the RAM and the content in a file in the external flash, to concatenate it all in a single datagram you can allocate a single area in the RAM that fits it all, and bring all the data to this memory. The problem with this approach is the amount of memory required for that, which can be multiple times the total RAM that you have for the entire system.</p>
<p>A second option to solve this problem is to make each component that needs to access this data understand each media and implement code to handle it. This approach will not require storing all data in the RAM, but will increase the size of the program itself, and is not easily portable, as different hardware will contain different media with different requirements.</p>
<p>The uStream solves this problem by creating a single interface that can handle any media, exposing it as a standard iterator. Whoever wants to expose a type of media as a uStream shall implement the functions described on the interface, handling all implementation details for each API. For example, the <a class="el" href="ustream__base_8h.html#ad136e857813def18c0261a686b74a681" title="Gets the next portion of the uStream starting at the current position.">aziot_ustream_read()</a> can be a simple copy of the flash to the RAM for a buffer that handles constants, or be as complex as creating a TCP/IP connection to bring the data for a buffer that handles data in the cloud.</p>
<p>The consumer of the uStream can use all kinds of media in the same way, and may easily concatenate it by exposing a uStream that handles multiple uStream's.</p>
<h2>Ownership</h2>
<p>The uStream is an owner-less buffer: every instance of the uStream has the same rights. They all can read the uStream content, release the parts that are not necessary anymore, and dispose it. Each instance of the uStream is owned by who created it, and should never be shared by multiple consumers. When a consumer receives a uStream and intends to make operations over it, this consumer must first make a clone of the uStream, creating its own instance of it, and then make the needed operations. </p>
<p>Cloning a uStream creates a new set of controls for the uStream that will share the same content of the original uStream. The content itself is a smart pointer with a <code>ref_count</code> that controls the total number of instances. </p>
<p>Disposing an instance of the uStream will decrease the <code>ref_count</code> of this uStream. If the number of references reaches 0, the uStream will destroy itself, releasing all allocated memory.</p>
<dl class="section warning"><dt>Warning</dt><dd>Not disposing an instance of the uStream will leak memory.</dd></dl>
<p>Instances of the uStream can be created in 2 ways:</p><ul>
<li><b>Factory</b> - when a producer exposes data using a uStream, it must create the uStream using a factory, so the operation <code>uStream create</code> returns the first instance of the uStream.</li>
<li><b>Clone</b> - when a consumer needs a copy of the uStream, it can use the <a class="el" href="ustream__base_8h.html#ae9ab120cb2e618f0d650c0938c32a97b" title="Creates a new instance of the uStream and returns it.">aziot_ustream_clone()</a>.</li>
</ul>
<h2>Thread safe</h2>
<p>The uStream <b>IS NOT</b> thread safe for multiple accesses over the same instance. The ownership of the instance of a uStream shall <b>NOT</b> be shared, especially not by consumers that run on different threads. The owner thread shall create a clone of the uStream and pass it to the other thread. The uStream <b>IS</b> thread safe for accesses between instances. It means that any access to memory shared by multiple instances shall be thread safe.</p>
<h2>Data retention</h2>
<p>As with any buffer, this uStream shall be used to handle data that was created by the producer as a result of an operation.</p>
<p>This interface only exposes read functions, so once created, the content of the uStream cannot be changed by the producer of any of the consumers. Changing the content of the data source will result in a data mismatch.</p>
<p>Consumers can do a partial release of the uStream by calling <a class="el" href="ustream__base_8h.html#abeea0517ae993f549c2901730746c7a8" title="Releases all the resources related to the Data Source before and including the released position.">aziot_ustream_release()</a>. Calling the release does not imply that part of the memory will be immediately released. Once a uStream can handle multiple instances, a memory can only be free'd if all instances release it. A uStream implementation can or cannot have the ability to do partial releases. For instance, a uStream that handles constant data stored in the flash will never release any memory on the <a class="el" href="ustream__base_8h.html#abeea0517ae993f549c2901730746c7a8" title="Releases all the resources related to the Data Source before and including the released position.">aziot_ustream_release()</a> API.</p>
<p>Released data cannot be accessed, even if it is still available in the memory.</p>
<h2>Appendable</h2>
<p>New data can be appended at the end of the uStream by calling <a class="el" href="ustream__base_8h.html#a59af936377f98e35cfd035f20ca3f5e7" title="Append a uStream to the existing uStream.">aziot_ustream_append()</a>. This can include uStream's from other different medias. In this way, the uStream can be used as a Stream of data. To protect the immutability of the uStream, appending a new uStream to an existing one will only affect the instance that is calling the <a class="el" href="ustream__base_8h.html#a59af936377f98e35cfd035f20ca3f5e7" title="Append a uStream to the existing uStream.">aziot_ustream_append()</a>.</p>
<p><em><b>Example</b></em> A producer created 3 uStreams named A, B, and C. At this point, it handles one instance of each uStream. A consumer received an instance of the uStream A and C, and appends C to A creating a new uStream AC. After that, the producer will append B to A, creating the new AB uStream.</p>
<p>Observe the fact that the consumer appending C to A on its own instance didn't affect the uStream A on the producer, and when the producer appended B to A, it creates AB, not ACB, and it didn't change the consumer AB uStream creating ABC or ACB on it.</p>
<h2>Lazy</h2>
<p>The uStream can contain the full content, bring it into memory when required, or even create the content when it is necessary. The implementation of the <a class="el" href="ustream__base_8h.html#ad136e857813def18c0261a686b74a681" title="Gets the next portion of the uStream starting at the current position.">aziot_ustream_read()</a> function can be smart enough to use the minimal amount of memory.</p>
<p>The only restriction is if a consumer accesses the same position of the uStream multiple times, it shall return the same data.</p>
<p><em><b>Example</b></em> A random number generator can expose random numbers using the uStream. To do that it shall generate a new number when the consumer calls <a class="el" href="ustream__base_8h.html#ad136e857813def18c0261a686b74a681" title="Gets the next portion of the uStream starting at the current position.">aziot_ustream_read()</a>. But to preserve the immutability, the implementation of the <a class="el" href="ustream__base_8h.html#ad136e857813def18c0261a686b74a681" title="Gets the next portion of the uStream starting at the current position.">aziot_ustream_read()</a> shall store the number in a recover queue, up to the point that the consumer releases this data. Because, if at some point in time, the consumer seeks this old position, the <a class="el" href="ustream__base_8h.html#ad136e857813def18c0261a686b74a681" title="Gets the next portion of the uStream starting at the current position.">aziot_ustream_read()</a> shall return the same value created in the first call of <a class="el" href="ustream__base_8h.html#ad136e857813def18c0261a686b74a681" title="Gets the next portion of the uStream starting at the current position.">aziot_ustream_read()</a>.</p>
<h2>Data conversion</h2>
<p>When the data is copied from the data source to the local buffer, the <a class="el" href="ustream__base_8h.html#ad136e857813def18c0261a686b74a681" title="Gets the next portion of the uStream starting at the current position.">aziot_ustream_read()</a> may do a data conversion, which means that the content exposed on the local buffer is a function of the content in the data source. It directly implies that the number of bytes written in the local buffer may be different than the number of bytes read from the data source.</p>
<p><em><b>Example</b></em> A uStream can have the data source in binary format with 36 bytes, but it shall expose the content encoded in base64. The base64 creates 4 encoded bytes for each 3 bytes read. So, seeking the beginning of the file, the <a class="el" href="ustream__base_8h.html#a42807a0d0c70f512774a380a05185e56" title="Returns the remaining size of the uStream.">aziot_ustream_get_remaining_size()</a> shall return 48 (= 36 / 3 * 4), instead of 36. If the consumer provides a local buffer of 16 bytes, the <a class="el" href="ustream__base_8h.html#ad136e857813def18c0261a686b74a681" title="Gets the next portion of the uStream starting at the current position.">aziot_ustream_read()</a> shall read only 12 bytes from the data source, and encode it in base64 expanding the 12 bytes to 16 bytes on the local buffer. </p><pre><code>
                 uStream domain                      ::      consumer domain
                                                     ::
                   Data source                       ::
                   +-------+--------------------+    ::
   binary data --&gt; |       |                    |    ::
                   +-------+--------------------+    ::
inner position --&gt; 0       12                   36   ::
                    --+--/                          ::      Local buffer
                       | size = 12                   ::      +----------------+
                       +---&gt; base64 encoder ---------------&gt; | base64         |
                                                     ::      +----------------+
                                                     ::        size' = 16
</code></pre><h2>Data offset</h2>
<p>In the data source, each byte is associated with a position, called <code>inner position</code>. The first byte is always placed at the inner position <code>0</code>, followed by the other bytes which are incremented in a sequential manner. The uStream assigns a sequential number to each byte in the local buffer as well, called <code>logical position</code>. When a new uStream is created, the logical position matches the inner position, both starting at position <code>0</code>.</p>
<p>When the uStream is cloned, an offset shall be provided. This offset is the new first logical position. The implementation of the uStream shall handle the difference between the inner and logical position, making the conversion in all the uStream API. Providing an offset to a uStream can be useful in many cases. For example, to concatenate buffers, the second uStream can have an offset of the end of the first uStream plus one, or in a TCP connection, make the logical position the same value of the octet sequence number.</p>
<p><em><b>Example</b></em> A uStream was created from the flash with 100 bytes. The inner position is a sequence from <code>0</code> to <code>99</code>, and it matches the logical position. The consumer clones this uStream providing an offset of <code>1000</code>. The new instance contains the same content as the original one, but the logical positions are now from <code>1000</code> to <code>1099</code>.</p>
<p>If the owner of the first instance wants to set the position to position 10, it shall call <a class="el" href="ustream__base_8h.html#a14cee0219d3b0168050603b63de6ab95" title="Change the current position of the uStream.">aziot_ustream_set_position()</a> with the logical position 10. For the cloned instance, to set the position to the same position 10, it shall call <a class="el" href="ustream__base_8h.html#a14cee0219d3b0168050603b63de6ab95" title="Change the current position of the uStream.">aziot_ustream_set_position()</a> with the logical position 1010.</p>
<h2>Sliding window</h2>
<p>One of the target use cases of the uStream is to accelerate and simplify the implementation of sliding window protocols, like TCP. As described in this document, the uStream associates a single byte (octet) to a single position, which means that every byte can be accessed by its position. For the consumer, this position is the logical position.</p>
<p>To better understand the sliding window concept of the uStream, the Data source can be split in 4 segments.</p>
<pre><code>
     Data Source:
          Released                       Pending                          Future
      |----------------|---------------------:--------------------|---------------------|
      |\                \                    :       Read         |\                    |
      | 0           First Valid Position     :                    | Current Position    |
      |                                      :                    |                     |
      |                                      :&lt;--- Read Size ----&gt;|                     |
      |                                                                                 |
      |&lt;------------------------------ Data Source Size -------------------------------&gt;|
</code></pre><ul>
<li><b>Released</b> - Sequence of bytes in the data source that is already acknowledged by the consumer, and shall not be accessed anymore.</li>
<li><b>Pending</b> - Sequence of bytes in the data source that is already read by the consumer, but not acknowledged yet. The consumer can seek these bytes with <a class="el" href="ustream__base_8h.html#a14cee0219d3b0168050603b63de6ab95" title="Change the current position of the uStream.">aziot_ustream_set_position()</a> and read it again. This sequence starts at the <code>First Valid Position</code> and ends at the last byte before the <code>Current Position</code>.</li>
<li><b>Read</b> - The last read portion of the data source. On the read operation, the <code>Read</code> starts at the <code>Current Position</code> up to the <code>Read Size</code>. At the end of the read, this segment is incorporated to <code>Pending</code> by changing the <code>Current Position</code> to the end of the Read.</li>
<li><b>Future</b> - Sequence of bytes in the data source that is not read by the consumer yet. It starts at the <code>Current Position</code> and ends at the end of the data source, which has the position calculated by <code>Data Source Size - 1</code>.</li>
</ul>
<p>To read a new portion of the data source, the consumer shall provide memory (the local buffer), where the implementation of the uStream will write the bytes that were read and converted from the data source. The consumer can use this data in its own context: for example, to transmit as a TCP packet. When the consumer finishes using the data in the local buffer, this data can be discarded and the local buffer recycled to get the next portion of the data source.</p>
<p>If at some point in the future, the consumer needs this data again, it can set the position to the needed position and get the same content using the read.</p>
<p>The consumer may confirm that a portion of the data is not necessary anymore. For example, after transmitting multiple TCP packets, the receiver of these packets answers with an ACK for a sequence number. In this case, the consumer can release this data in the data source by calling the <a class="el" href="ustream__base_8h.html#abeea0517ae993f549c2901730746c7a8" title="Releases all the resources related to the Data Source before and including the released position.">aziot_ustream_release()</a>, moving the <code>First Valid Position</code> to the next one after the released position.</p>
<p>A common scenario is when the consumer needs to read over the data source starting on the first byte after the last released one. For example, when a timeout happens for a transmitted packet without ACK, the sender shall retransmit the data starting from that point. In this case, the consumer can call the API <a class="el" href="ustream__base_8h.html#ad90577ebc92e787b53bed8af5560a670" title="Changes the current position to the first valid position.">aziot_ustream_reset()</a>. </p>

<p class="definition">Definition in file <a class="el" href="ustream__base_8h_source.html">ustream_base.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9f3237e600295f7aa5483bec5bf71d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3237e600295f7aa5483bec5bf71d4a">&#9670;&nbsp;</a></span>AZIOT_USTREAM_IS_NOT_TYPE_OF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AZIOT_USTREAM_IS_NOT_TYPE_OF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">handle, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_api&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((handle == NULL) || (handle-&gt;api != &amp;type_api))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a handle is the same type of the API. </p>
<p>It will return true if the handle is valid and it is the same type of the API. It will return false if the handle is <code>NULL</code> or not the correct type. </p>

<p class="definition">Definition at line <a class="el" href="ustream__base_8h_source.html#l00367">367</a> of file <a class="el" href="ustream__base_8h_source.html">ustream_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a59af936377f98e35cfd035f20ca3f5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59af936377f98e35cfd035f20ca3f5e7">&#9670;&nbsp;</a></span>aziot_ustream_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> aziot_ustream_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *&#160;</td>
          <td class="paramname"><em>ustream_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *&#160;</td>
          <td class="paramname"><em>ustream_to_append</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a uStream to the existing uStream. </p>
<p>The append will add a uStream at the end of the current one. To do that, the append will convert the <code>ustream_interface</code> to a <code>USTREAM_MULTI_INSTANCE</code>, and append a clone of <code>ustream_to_append</code> to it. If <code>ustream_interface</code> is already an instance of a <code>USTREAM_MULTI_INSTANCE</code>, this API will only append <code>ustream_to_append</code>.</p>
<p>The <code>aziot_ustream_append</code> API shall follow the following minimum requirements:</p><ul>
<li>The <code>append</code> shall append <code>ustream_to_append</code> to the end of <code>ustream_interface</code>.</li>
<li>If <code>ustream_interface</code> is not a <code>USTREAM_MULTI_INSTANCE</code>, the <code>append</code> shall convert it to a <code>USTREAM_MULTI_INSTANCE</code>.</li>
<li>If <code>ustream_interface</code> is <code>NULL</code>, the <code>append</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If <code>ustream_to_append</code> is <code>NULL</code>, the <code>append</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If there is not enough memory to append the uStream, the <code>append</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58a8f41ea4956308ff99ba07f01ab7750e6">AZIOT_ULIB_OUT_OF_MEMORY_ERROR</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ustream_interface</td><td>The <a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a>* with the interface of the uStream. It cannot be <code>NULL</code>, and it shall be a valid uStream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ustream_to_append</td><td>The <a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a>* with the interface of the uStream to be appended to the original uStream. It cannot be <code>NULL</code>, and it shall be a valid uStream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> with the result of the <code>append</code> operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">AZIOT_ULIB_SUCCESS</td><td>If the uStream was appended with success. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</td><td>If one of the provided parameters is invalid. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_OUT_OF_MEMORY_ERROR</td><td>If there is no memory to <code>append</code> the uStream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9ab120cb2e618f0d650c0938c32a97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ab120cb2e618f0d650c0938c32a97b">&#9670;&nbsp;</a></span>aziot_ustream_clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a>* aziot_ustream_clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *&#160;</td>
          <td class="paramname"><em>ustream_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ustream__base_8h.html#ad6d3ac7a653ebc380309a369ca677d58">offset_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new instance of the uStream and returns it. </p>
<p>Cloning a uStream will create a new instance of the uStream that shares the same content of the original one. The clone shall not copy the content of the uStream, but only add a reference to it.</p>
<p>Both the start position and the current position of the cloned uStream will be the current position of the original uStream. The logical position of it will be determined by the provided offset.</p>
<p>The size of the new uStream will be the remaining size of the original uStream, which is the size minus the current position.</p>
<p><em><b>Example 1</b></em></p>
<p>Consider a uStream with 1500 bytes, that was created from the factory, with <code>Logical</code> and <code>Inner</code> positions equal to <code>0</code>. After some operations, 1000 bytes were read (from 0 to 999). The current position is <code>1000</code>, and 200 bytes were released (from 0 to 199), so the released position is <code>199</code>. For the following examples, the positions are represented by <code>[Logical, Inner]</code>.</p>
<p>Original uStream:</p>
<pre><code></code></pre><pre><code> |      Released     |             Pending             |               Future              |
 |-------------------|---------------------------------|-----------------------------------|
 |&lt;- start [0, 0]    |&lt;- released [199, 199]           |&lt;- current [1000, 1000]            |&lt;- end [1499, 1499]</code></pre><pre><code></code></pre><p>Cloning the original uStream with offset 0 will result in the following uStream:</p>
<pre><code></code></pre><pre><code>                      |||             Future                |
                      |||-----------------------------------|
 released [-1, 999] -&gt;|||&lt;- start, current [0, 1000]        |&lt;- end [499, 1499]</code></pre><pre><code></code></pre><p>Cloning the same original uStream with offset 100 will result in the following uStream:</p>
<pre><code></code></pre><pre><code>                      |||             Future                |
                      |||-----------------------------------|
 released [99, 999] -&gt;|||&lt;- start, current [100, 1000]      |&lt;- end [599, 1499]</code></pre><pre><code></code></pre><p><em><b>Example 2</b></em></p>
<p>Consider a uStream with 5000 bytes, that was created from the factory, with <code>Logical</code> and <code>Inner</code> positions equal to <code>0</code>. After some operations, 250 bytes were read (from 0 to 249), so the current position is <code>250</code>, and no release was made, so the released position is still <code>-1</code>.</p>
<p>For the following examples, the positions are represented by <code>[Logical, Inner]</code>.</p>
<p>Original uStream:</p>
<pre><code></code></pre><pre><code>                    ||     Pending       |                         Future                      |
                    ||-------------------+-----------------------------------------------------|
 released [-1, 0] -&gt;||&lt;- start [0, 0]    |&lt;- current [250, 250]                                |&lt;- end [4999, 4999]</code></pre><pre><code></code></pre><p>Cloning this original uStream with offset 10000 will result in the following uStream:</p>
<pre><code></code></pre><pre><code>                        |||                Future                |
                        |||--------------------------------------|
 released [9999, 249] -&gt;|||&lt;- start, current [10000, 250]        |&lt;- end [14749, 4999]</code></pre><pre><code></code></pre><p><em><b>Example 3</b></em></p>
<p>From the previous cloned uStream, after some operations, the <code>Logical</code> current position is moved to <code>11000</code>, and the <code>Logical</code> released position is <code>10499</code>.</p>
<p>For the following examples, the positions are represented by <code>[Logical, Inner]</code>.</p>
<p>Previous cloned uStream:</p>
<pre><code></code></pre><pre><code> |          Released       |           Pending          |               Future              |
 |-------------------------+----------------------------+-----------------------------------|
 |&lt;- start [10000, 250]    |&lt;- released [10499, 749]    |&lt;- current [11000, 1250]           |&lt;- end [14749, 4999]</code></pre><pre><code></code></pre><p>Cloning this cloned uStream with offset 0 will result in the following uStream:</p>
<pre><code></code></pre><pre><code>                       |||                Future                |
                       |||--------------------------------------|
 released [-1, 1249] -&gt;|||&lt;- start, current [0, 1250]           |&lt;- end [3749, 4999]</code></pre><pre><code></code></pre><dl class="section note"><dt>Note</dt><dd>From the point of view of a consumer, the <code>Inner</code> position never matters, it will always use the <code>Logical</code> position for all operations. </dd>
<dd>
If the position is not important to the consumer, making the offset equal to <code>0</code> is a safe option.</dd></dl>
<p>The <code>aziot_ustream_clone</code> API shall follow the following minimum requirements:</p><ul>
<li>The <code>clone</code> shall return a uStream with the same content of the original uStream.</li>
<li>If the provided interface is <code>NULL</code>, the <code>clone</code> shall return <code>NULL</code>.</li>
<li>If the provided interface is not a type of the implemented uStream, the <code>clone</code> shall return <code>NULL</code>.</li>
<li>If there is not enough memory to control the new uStream, the <code>clone</code> shall return <code>NULL</code>.</li>
<li>If the provided offset plus the uStream size is bigger than the maximum size_t, the <code>clone</code> shall return <code>NULL</code>.</li>
<li>The cloned uStream shall not interfere with the instance of the original uStream and vice versa.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ustream_interface</td><td>The <a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a>* with the interface of the uStream. It cannot be <code>NULL</code>, and it shall be a valid uStream that is type of the implemented uStream. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">offset</td><td>The <code>offset_t</code> with the <code>Logical</code> position of the first byte in the cloned uStream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a>* with the result of the clone operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">not-NULL</td><td>If the uStream was cloned with success. </td></tr>
    <tr><td class="paramname">NULL</td><td>If one of the provided parameters is invalid or there is not enough memory to control the new uStream. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ustream__base_8h_source.html#l00759">759</a> of file <a class="el" href="ustream__base_8h_source.html">ustream_base.h</a>.</p>

</div>
</div>
<a id="a6453826de26b4a336372c2075ccb2a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6453826de26b4a336372c2075ccb2a46">&#9670;&nbsp;</a></span>aziot_ustream_dispose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> aziot_ustream_dispose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *&#160;</td>
          <td class="paramname"><em>ustream_interface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release all the resources allocated to control the instance of the uStream. </p>
<p>The dispose will release the instance of the uStream and decrement the reference of the uStream. If there are no more references to the uStream, the dispose will release all resources allocated to control the uStream.</p>
<p>The <code>aziot_ustream_dispose</code> API shall follow the following minimum requirements:</p><ul>
<li>The <code>dispose</code> shall free all allocated resources for the instance of the uStream.</li>
<li>If there are no more instances of the uStream, the <code>dispose</code> shall release all allocated resources to control the uStream.</li>
<li>If the provided interface is <code>NULL</code>, the <code>dispose</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If the provided interface is not the type of the implemented uStream, the <code>dispose</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ustream_interface</td><td>The <a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a>* with the interface of the uStream. It cannot be <code>NULL</code>, and it shall be a valid uStream that is a type of the implemented uStream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> with the result of the <code>dispose</code> operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">AZIOT_ULIB_SUCCESS</td><td>If the instance of the uStream was disposed with success. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</td><td>If one of the provided parameters is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ustream__base_8h_source.html#l00787">787</a> of file <a class="el" href="ustream__base_8h_source.html">ustream_base.h</a>.</p>

</div>
</div>
<a id="a4eaed6a11daecfd39aca4f0377b9779f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eaed6a11daecfd39aca4f0377b9779f">&#9670;&nbsp;</a></span>aziot_ustream_get_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> aziot_ustream_get_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *&#160;</td>
          <td class="paramname"><em>ustream_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ustream__base_8h.html#ad6d3ac7a653ebc380309a369ca677d58">offset_t</a> *const&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current position in the uStream. </p>
<p>This API returns the logical current position.</p>
<p>The <code>aziot_ustream_get_position</code> API shall follow the following minimum requirements:</p><ul>
<li>The <code>get_position</code> shall return the logical current position of the uStream.</li>
<li>If the provided interface is <code>NULL</code>, the <code>get_position</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If the provided interface is not the implemented uStream type, the <code>get_position</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If the provided position is <code>NULL</code>, the <code>get_position</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ustream_interface</td><td>The <a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a>* with the interface of the uStream. It cannot be <code>NULL</code>, and it shall be a valid uStream that is the implemented uStream type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">position</td><td>The <code>offset_t* const</code> to return the logical current position in the uStream. It cannot be <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> with the result of the <code>get_position</code> operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">AZIOT_ULIB_SUCCESS</td><td>If it provided the position of the uStream. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_BUSY_ERROR</td><td>If the resource necessary for getting the position is busy. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_CANCELLED_ERROR</td><td>If the <code>get_position</code> was cancelled. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</td><td>If one of the provided parameters is invalid. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_OUT_OF_MEMORY_ERROR</td><td>If there is not enough memory to execute the <code>get_position</code> operation. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_SECURITY_ERROR</td><td>If the <code>get_position</code> was denied for security reasons. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_SYSTEM_ERROR</td><td>If the <code>get_position</code> operation failed on the system level. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ustream__base_8h_source.html#l00571">571</a> of file <a class="el" href="ustream__base_8h_source.html">ustream_base.h</a>.</p>

</div>
</div>
<a id="a42807a0d0c70f512774a380a05185e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42807a0d0c70f512774a380a05185e56">&#9670;&nbsp;</a></span>aziot_ustream_get_remaining_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> aziot_ustream_get_remaining_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *&#160;</td>
          <td class="paramname"><em>ustream_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *const&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the remaining size of the uStream. </p>
<p>This API returns the number of bytes between the current position and the end of the uStream.</p>
<p>The <code>aziot_ustream_get_remaining_size</code> API shall follow the following minimum requirements:</p><ul>
<li>The <code>get_remaining_size</code> shall return the number of bytes between the current position and the end of the uStream.</li>
<li>If the provided interface is <code>NULL</code>, the <code>get_remaining_size</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If the provided interface is not the implemented uStream type, the <code>get_remaining_size</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If the provided size is <code>NULL</code>, the <code>get_remaining_size</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ustream_interface</td><td>The <a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a>* with the interface of the uStream. It cannot be <code>NULL</code>, and it shall be a valid uStream that is the implemented uStream type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>The <code>size_t* const</code> to return the remaining number of <code>uint8_t</code> values It cannot be <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> with the result of the <code>get_remaining_size</code> operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">AZIOT_ULIB_SUCCESS</td><td>If it succeeded to get the remaining size of the uStream. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_BUSY_ERROR</td><td>If the resource necessary to get the remaining size of the uStream is busy. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_CANCELLED_ERROR</td><td>If the <code>get_remaining_size</code> was cancelled. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</td><td>If one of the provided parameters is invalid. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_OUT_OF_MEMORY_ERROR</td><td>If there is not enough memory to execute the <code>get_remaining_size</code> operation. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_SECURITY_ERROR</td><td>If the <code>get_remaining_size</code> was denied for security reasons. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_SYSTEM_ERROR</td><td>If the <code>get_remaining_size</code> operation failed on the system level. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ustream__base_8h_source.html#l00535">535</a> of file <a class="el" href="ustream__base_8h_source.html">ustream_base.h</a>.</p>

</div>
</div>
<a id="ad136e857813def18c0261a686b74a681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad136e857813def18c0261a686b74a681">&#9670;&nbsp;</a></span>aziot_ustream_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> aziot_ustream_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *&#160;</td>
          <td class="paramname"><em>ustream_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *const&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the next portion of the uStream starting at the current position. </p>
<p>The <code>aziot_ustream_read</code> API will copy the contents of the Data source to the local buffer starting at the current position. The local buffer is the one referenced by the parameter <code>buffer</code>, and with the maximum size <code>buffer_length</code>.</p>
<p>The buffer is defined as a <code>uint8_t*</code> and can represent any sequence of data. Pay special attention, if the data is a string, the buffer will still copy it as a sequence of <code>uint8_t</code>, and will <b>NOT</b> put any terminator at the end of the string. The size of the content copied in the local buffer will be returned in the parameter <code>size</code>.</p>
<p>The <code>aziot_ustream_read</code> API shall follow the following minimum requirements:</p><ul>
<li>The read shall copy the contents of the <code>Data Source</code> to the provided local buffer.</li>
<li>If the contents of the <code>Data Source</code> is bigger than the <code>buffer_length</code>, the read shall limit the copy size up to the buffer_length.</li>
<li>The read shall return the number of valid <code>uint8_t</code> values in the local buffer in the provided <code>size</code>.</li>
<li>If there is no more content to return, the read shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58a1b082d915d984f836c1a7919a0462724">AZIOT_ULIB_EOF</a>, size shall be set to 0, and will not change the contents of the local buffer.</li>
<li>If the provided buffer_length is zero, the read shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If the provided buffer_length is lower than the minimum number of bytes that the uStream can copy, the read shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If the provided interface is <code>NULL</code>, the read shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If the provided interface is not the implemented uStream type, the read shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If the provided local buffer is <code>NULL</code>, the read shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If the provided return size pointer is <code>NULL</code>, the read shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a> and will not change the local buffer contents or the current position of the buffer.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ustream_interface</td><td>The <a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a>* with the interface of the uStream. It cannot be <code>NULL</code>, and it shall be a valid uStream that is the implemented uStream type. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>The <code>uint8_t* const</code> that points to the local buffer. It cannot be <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_length</td><td>The <code>size_t</code> with the size of the local buffer. It shall be bigger than 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>The <code>size_t* const</code> that points to the place where the read shall store the number of valid <code>uint8_t</code> values returned in the local buffer. It cannot be <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> with the result of the read operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">AZIOT_ULIB_SUCCESS</td><td>If the uStream copied the content of the <code>Data Source</code> to the local buffer with success. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_BUSY_ERROR</td><td>If the resource necessary to read the uStream content is busy. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_CANCELLED_ERROR</td><td>If the read of the content was cancelled. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</td><td>If one of the provided parameters is invalid. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_EOF</td><td>If there are no more <code>uint8_t</code> values in the <code>Data Source</code> to read. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_OUT_OF_MEMORY_ERROR</td><td>If there is not enough memory to execute the read. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_SECURITY_ERROR</td><td>If the read was denied for security reasons. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_SYSTEM_ERROR</td><td>If the read operation failed on the system level. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ustream__base_8h_source.html#l00499">499</a> of file <a class="el" href="ustream__base_8h_source.html">ustream_base.h</a>.</p>

</div>
</div>
<a id="abeea0517ae993f549c2901730746c7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeea0517ae993f549c2901730746c7a8">&#9670;&nbsp;</a></span>aziot_ustream_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> aziot_ustream_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *&#160;</td>
          <td class="paramname"><em>ustream_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ustream__base_8h.html#ad6d3ac7a653ebc380309a369ca677d58">offset_t</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases all the resources related to the <code><code>Data Source</code></code> before and including the released position. </p>
<p>Calling this API will notify the uStream that the user will not need its content from the start to <code>position</code> (inclusive). It means that the implementation of the uStream can dispose any resources allocated to control and maintain this part of the uStream. It is up to the implementation of the uStream to decide to release any resource. For example, if the uStream is a string in the Flash, it does not make sense to release it. The provided position shall be the logical position, and it shall be between the logical first valid position of the uStream and the logical current position minus one. For example, the following code releases all bytes from the start to the last received position:</p>
<pre><code>
offset_t pos;
if(aziot_ustream_get_position(my_buffer, &amp;pos) == AZIOT_ULIB_SUCCESS)
{
    aziot_ustream_release(my_buffer, pos - 1);
}
</code></pre><p>The <code>aziot_ustream_release</code> API shall follow the following minimum requirements:</p><ul>
<li>The <code>release</code> shall dispose all resources necessary to handle the content of uStream before and including the release position.</li>
<li>If the release position is after the current position or the uStream size, the <code>release</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>, and do not release any resource.</li>
<li>If the release position is already released, the <code>release</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58a8584dd9287482e1e04b8d4018ce266c4">AZIOT_ULIB_NO_SUCH_ELEMENT_ERROR</a>, and do not release any resource.</li>
<li>If the provided interface is <code>NULL</code>, the <code>release</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If the provided interface is not the implemented uStream type, the <code>release</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ustream_interface</td><td>The <a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a>* with the interface of the uStream. It cannot be <code>NULL</code>, and it shall be a valid uStream that is the implemented uStream type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The <code>offset_t</code> with the position in the uStream to release. The uStream will release the <code>uint8_t</code> on the position and all <code>uint8_t</code> before the position. It shall be bigger than 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> with the result of the <code>release</code> operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">AZIOT_ULIB_SUCCESS</td><td>If the uStream releases the position with success. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</td><td>If one of the provided parameters is invalid. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_NO_SUCH_ELEMENT_ERROR</td><td>If the position is already released. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_SYSTEM_ERROR</td><td>If the <code>release</code> operation failed on the system level. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ustream__base_8h_source.html#l00620">620</a> of file <a class="el" href="ustream__base_8h_source.html">ustream_base.h</a>.</p>

</div>
</div>
<a id="ad90577ebc92e787b53bed8af5560a670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90577ebc92e787b53bed8af5560a670">&#9670;&nbsp;</a></span>aziot_ustream_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> aziot_ustream_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *&#160;</td>
          <td class="paramname"><em>ustream_interface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the current position to the first valid position. </p>
<p>The current position is the one that will be returned in the local buffer by the next <a class="el" href="ustream__base_8h.html#ad136e857813def18c0261a686b74a681" title="Gets the next portion of the uStream starting at the current position.">aziot_ustream_read()</a>. Reset will bring the current position to the first valid one, which is the first byte after the released position.</p>
<p>The <code>aziot_ustream_reset</code> API shall follow the following minimum requirements:</p><ul>
<li>The <code>reset</code> shall change the current position of the uStream to the first byte after the released position.</li>
<li>If all bytes are already released, the uStream <code>reset</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58a8584dd9287482e1e04b8d4018ce266c4">AZIOT_ULIB_NO_SUCH_ELEMENT_ERROR</a>, and will not change the current position.</li>
<li>If the provided interface is <code>NULL</code>, the uStream <code>reset</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If the provided interface is not the implemented uStream type, the uStream <code>reset</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ustream_interface</td><td>The <a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a>* with the interface of the uStream. It cannot be <code>NULL</code>, and it shall be a valid uStream that is the implemented uStream type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> with the result of the <code>reset</code> operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">AZIOT_ULIB_SUCCESS</td><td>If the uStream changed the current position with success. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_BUSY_ERROR</td><td>If the resource necessary for the <code>reset</code> operation is busy. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_CANCELLED_ERROR</td><td>If the <code>reset</code> operation was cancelled. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</td><td>If one of the provided parameters is invalid. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_NO_SUCH_ELEMENT_ERROR</td><td>If all previous bytes in the uStream were already released. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_OUT_OF_MEMORY_ERROR</td><td>If there is not enough memory to execute the <code>reset</code> operation. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_SECURITY_ERROR</td><td>If the <code>reset</code> operation was denied for security reasons. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_SYSTEM_ERROR</td><td>If the <code>reset</code> operation failed on the system level. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ustream__base_8h_source.html#l00442">442</a> of file <a class="el" href="ustream__base_8h_source.html">ustream_base.h</a>.</p>

</div>
</div>
<a id="a14cee0219d3b0168050603b63de6ab95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14cee0219d3b0168050603b63de6ab95">&#9670;&nbsp;</a></span>aziot_ustream_set_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> aziot_ustream_set_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a> *&#160;</td>
          <td class="paramname"><em>ustream_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ustream__base_8h.html#ad6d3ac7a653ebc380309a369ca677d58">offset_t</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the current position of the uStream. </p>
<p>The current position is the one that will be returned in the local buffer by the next <a class="el" href="ustream__base_8h.html#ad136e857813def18c0261a686b74a681" title="Gets the next portion of the uStream starting at the current position.">aziot_ustream_read()</a>. Consumers can call this API to go back or forward, but it cannot exceed the end of the uStream or precede the fist valid position (last released position + 1).</p>
<p>The <code>aziot_ustream_set_position</code> API shall follow these minimum requirements:</p><ul>
<li>The <code>set_position</code> shall change the current position of the uStream.</li>
<li>If the provided position is out of the range of the uStream, the <code>set_position</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58a8584dd9287482e1e04b8d4018ce266c4">AZIOT_ULIB_NO_SUCH_ELEMENT_ERROR</a>, and will not change the current position.</li>
<li>If the provided position is already released, the <code>set_position</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58a8584dd9287482e1e04b8d4018ce266c4">AZIOT_ULIB_NO_SUCH_ELEMENT_ERROR</a>, and will not change the current position.</li>
<li>If the provided interface is <code>NULL</code>, the <code>set_position</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
<li>If the provided interface is not the implemented uStream type, the <code>set_position</code> shall return <a class="el" href="ulib__result_8h.html#af2b409310c76038a59615f683cd01f58aee37d4a362445046b2ebae4ee4c02727">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ustream_interface</td><td>The <a class="el" href="ustream__base_8h.html#a6f1021e37ea11b8861699ca4525ae307">AZIOT_USTREAM</a>* with the interface of the uStream. It cannot be <code>NULL</code>, and it shall be a valid uStream that is the implemented uStream type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The <code>offset_t</code> with the new current position in the uStream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="ulib__result_8h.html#a5fe430f1ff89082b4838d8574614b53b">AZIOT_ULIB_RESULT</a> with the result of the <code>set_position</code> operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">AZIOT_ULIB_SUCCESS</td><td>If the uStream changed the current position with success. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_BUSY_ERROR</td><td>If the resource necessary for the <code>set_position</code> operation is busy. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_CANCELLED_ERROR</td><td>If the <code>set_position</code> operation was cancelled. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_ILLEGAL_ARGUMENT_ERROR</td><td>If one of the provided parameters is invalid. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_NO_SUCH_ELEMENT_ERROR</td><td>If the position is out of the uStream range. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_OUT_OF_MEMORY_ERROR</td><td>If there is not enough memory to execute the <code>set_position</code> operation. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_SECURITY_ERROR</td><td>If the <code>set_position</code> operation was denied for security reasons. </td></tr>
    <tr><td class="paramname">AZIOT_ULIB_SYSTEM_ERROR</td><td>If the <code>set_position</code> operation failed on the system level. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ustream__base_8h_source.html#l00403">403</a> of file <a class="el" href="ustream__base_8h_source.html">ustream_base.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
